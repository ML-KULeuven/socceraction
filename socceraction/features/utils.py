"""Utility functions for feature generation."""

from functools import wraps
from typing import Any, Callable, Literal, no_type_check

import numpy as np
import pandas as pd
from pandera.typing import DataFrame

from socceraction.spadl import to_gamestates
from socceraction.types import Actions, Features, GameStates, Mask

_FEATURE_REGISTRY = {}


@no_type_check
def feature_generator(
    ftype: Literal["actions", "gamestates", "events"], features: list[str] | None = None
) -> Callable[..., Features]:
    """Register a feature transformation function.

    Parameters
    ----------
    ftype : str
        The type of feature. Must be one of "actions", "gamestates", or "events".
    features : list of str, optional
        List of feature names to be registered. Defaults to None.

    Returns
    -------
    Callable
        A decorator that applies the feature transformation and sets the `ftype` attribute.

    Raises
    ------
    ValueError
        If `ftype` is not one of "actions", "gamestates", or "events".
    """
    if ftype not in ["actions", "gamestates", "events"]:
        raise ValueError(
            f"Invalid ftype: {ftype}. Must be one of 'actions', 'gamestates', or 'events'."
        )

    def decorate_func(func: Callable[..., Features]) -> Callable[..., Features]:
        @wraps(func)
        def feature_transformer(
            data: DataFrame[Any],
            mask: Mask | None = None,
            **kwargs,  # noqa: ANN003
        ) -> Features:
            if mask is None:
                if ftype == "gamestates":
                    return func(data, [True] * len(data[0]))
                return func(data, [True] * len(data), **kwargs)
            return func(data, mask, **kwargs)

        feature_transformer.ftype = ftype
        if features is not None:
            for feature in features:
                _FEATURE_REGISTRY[feature] = feature_transformer
        return feature_transformer

    return decorate_func


@no_type_check
def create_gamestate_features(
    actionfn: Callable[[Actions], Features],
) -> Callable[[Actions], Features]:
    """Make a function decorator to apply actionfeatures to game states.

    Parameters
    ----------
    actionfn : Callable
        A feature transformer that operates on actions.

    Returns
    -------
    Callable
        A feature transformer that operates on game states.
    """

    @wraps(actionfn)
    def _wrapper(gamestates: GameStates, **kwargs) -> pd.DataFrame:  # noqa: ANN003
        if not isinstance(gamestates, (list,)):
            gamestates = [gamestates]
        X = []
        for i, a in enumerate(gamestates):
            Xi = actionfn(a, **kwargs)
            Xi.columns = [c + "_a" + str(i) for c in Xi.columns]
            X.append(Xi)
        return pd.concat(X, axis=1)

    _wrapper.ftype = "gamestates"

    return _wrapper


def feature_column_names(fs: list[Callable[..., Features]], nb_prev_actions: int = 3) -> list[str]:
    """Return the names of the features generated by a list of transformers.

    Parameters
    ----------
    fs : list(callable)
        A list of feature transformers.
    nb_prev_actions : int, default=3  # noqa: DAR103
        The number of previous actions included in the game state.

    Returns
    -------
    list(str)
        The name of each generated feature.
    """
    spadlcolumns = [
        "game_id",
        "original_event_id",
        "action_id",
        "period_id",
        "time_seconds",
        "team_id",
        "player_id",
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "result_id",
        "result_name",
        "bodypart_id",
        "bodypart_name",
        "type_id",
        "type_name",
    ]
    dummy_actions = pd.DataFrame(np.zeros((10, len(spadlcolumns))), columns=spadlcolumns)
    for c in spadlcolumns:
        if "name" in c:
            dummy_actions[c] = dummy_actions[c].astype(str)
    gs = to_gamestates(dummy_actions, nb_prev_actions)  # type: ignore
    return list(pd.concat([f(gs) for f in fs], axis=1).columns.values)
