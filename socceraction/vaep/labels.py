"""Implements the label tranformers of the VAEP framework."""

from functools import reduce

import pandas as pd

import socceraction.spadl.config as spadl
from socceraction.features.utils import feature_generator
from socceraction.types import Features, Mask, SPADLActions
from socceraction.utils import deprecated


@feature_generator("actions", features=["scores"])
def scores(actions: SPADLActions, mask: Mask, nr_actions: int = 10) -> Features:
    """Determine whether the team possessing the ball scored a goal within the next x actions.

    Parameters
    ----------
    actions : SPADLActions
        The actions of a game.
    mask : Mask
        A boolean mask to filter actions.
    nr_actions : int, default=10  # noqa: DAR103
        Number of actions after the current action to consider.

    Returns
    -------
    Features
        A dataframe with a column 'scores' and a row for each action set to
        True if a goal was scored by the team possessing the ball within the
        next x actions; otherwise False.
    """
    # merging goals, owngoals and team_ids

    goals = actions["type_name"].str.contains("shot") & (
        actions["result_id"] == spadl.results.index("success")
    )
    owngoals = actions["type_name"].str.contains("shot") & (
        actions["result_id"] == spadl.results.index("owngoal")
    )
    y = pd.concat([goals, owngoals, actions["team_id"]], axis=1)
    y.columns = ["goal", "owngoal", "team_id"]

    # adding future results
    for i in range(1, nr_actions):
        for c in ["team_id", "goal", "owngoal"]:
            shifted = y[c].shift(-i)
            shifted[-i:] = y[c].iloc[len(y) - 1]
            y["%s+%d" % (c, i)] = shifted

    res = y["goal"]
    for i in range(1, nr_actions):
        gi = y["goal+%d" % i] & (y["team_id+%d" % i] == y["team_id"])
        ogi = y["owngoal+%d" % i] & (y["team_id+%d" % i] != y["team_id"])
        res = res | gi | ogi

    return pd.DataFrame(res, columns=["scores"]).loc[mask]


@feature_generator("actions", features=["concedes"])
def concedes(actions: SPADLActions, mask: Mask, nr_actions: int = 10) -> Features:
    """Determine whether the team possessing the ball conceded a goal within the next x actions.

    Parameters
    ----------
    actions : SPADLActions
        The actions of a game.
    mask : Mask
        A boolean mask to filter actions.
    nr_actions : int, default=10  # noqa: DAR103
        Number of actions after the current action to consider.

    Returns
    -------
    Features
        A dataframe with a column 'concedes' and a row for each action set to
        True if a goal was conceded by the team possessing the ball within the
        next x actions; otherwise False.
    """
    # merging goals,owngoals and team_ids
    goals = actions["type_name"].str.contains("shot") & (
        actions["result_id"] == spadl.results.index("success")
    )
    owngoals = actions["type_name"].str.contains("shot") & (
        actions["result_id"] == spadl.results.index("owngoal")
    )
    y = pd.concat([goals, owngoals, actions["team_id"]], axis=1)
    y.columns = ["goal", "owngoal", "team_id"]

    # adding future results
    for i in range(1, nr_actions):
        for c in ["team_id", "goal", "owngoal"]:
            shifted = y[c].shift(-i)
            shifted[-i:] = y[c].iloc[len(y) - 1]
            y["%s+%d" % (c, i)] = shifted

    res = y["owngoal"]
    for i in range(1, nr_actions):
        gi = y["goal+%d" % i] & (y["team_id+%d" % i] != y["team_id"])
        ogi = y["owngoal+%d" % i] & (y["team_id+%d" % i] == y["team_id"])
        res = res | gi | ogi

    return pd.DataFrame(res, columns=["concedes"]).loc[mask]


@feature_generator("actions", features=["scores_xg"])
def scores_xg(actions: SPADLActions, mask: Mask, nr_actions: int = 10) -> Features:
    """Determine the xG value generated by the team possessing the ball within the next x actions.

    Parameters
    ----------
    actions : SPADLActions
        The actions of a game.
    mask : Mask
        A boolean mask to filter actions.
    nr_actions : int, default=10  # noqa: DAR103
        Number of actions after the current action to consider.

    Returns
    -------
    Features
        A dataframe with a column 'scores_xg' and a row for each action set to
        the total xG value generated by the team possessing the ball within the
        next x actions.
    """
    y = actions.loc[:, ["xg", "team_id"]].fillna(0)
    y.columns = ["shot", "team_id"]

    # adding future results
    for i in range(1, nr_actions):
        for c in ["team_id", "shot"]:
            shifted = y[c].shift(-i)
            shifted[-i:] = 0.0
            y["%s+%d" % (c, i)] = shifted

    # removing opponent shots
    for i in range(1, nr_actions):
        y.loc[(y["team_id+%d" % i] != y["team_id"]), "shot+%d" % i] = 0

    # combine multiple shots in possession
    # see https://fbref.com/en/expected-goals-model-explained
    y["sum"] = 1
    y["scores_xg"] = 1 - y[["sum", "shot"] + ["shot+%d" % i for i in range(1, nr_actions)]].apply(
        lambda shots: reduce(lambda agg, xg: agg * (1 - xg), shots), axis=1
    )
    return y.loc[mask, ["scores_xg"]]


@feature_generator("actions", features=["concedes_xg"])
def concedes_xg(actions: pd.DataFrame, mask: Mask, nr_actions: int = 10) -> Features:
    """Determine the xG value conceded by the team possessing the ball within the next x actions.

    Parameters
    ----------
    actions : pd.DataFrame
        The actions of a game.
    mask : Mask
        A boolean mask to filter actions.
    nr_actions : int, default=10  # noqa: DAR103
        Number of actions after the current action to consider.

    Returns
    -------
    Features
        A dataframe with a column 'concedes_xg' and a row for each action set to
        the total xG value conceded by the team possessing the ball within the
        next x actions.
    """
    y = actions.loc[:, ["xg", "team_id"]].fillna(0)
    y.columns = ["shot", "team_id"]

    # adding future results
    for i in range(1, nr_actions):
        for c in ["team_id", "shot"]:
            shifted = y[c].shift(-i)
            shifted[-i:] = 0.0
            y["%s+%d" % (c, i)] = shifted

    # removing created shots
    for i in range(1, nr_actions):
        y.loc[(y["team_id+%d" % i] == y["team_id"]), "shot+%d" % i] = 0

    # combine multiple shots in possession
    # see https://fbref.com/en/expected-goals-model-explained
    y["sum"] = 1
    y["concedes_xg"] = 1 - y[["sum"] + ["shot+%d" % i for i in range(1, nr_actions)]].apply(
        lambda shots: reduce(lambda agg, xg: agg * (1 - xg), shots), axis=1
    )
    return y.loc[mask, ["concedes_xg"]]


@deprecated("Use socceraction.xg.labels.goal_from_shot instead.")
def goal_from_shot(actions: SPADLActions, mask: Mask) -> Features:
    """See socceraction.xg.labels.goal_from_shot."""
    from socceraction.xg.labels import goal_from_shot

    return goal_from_shot
